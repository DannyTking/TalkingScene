#ifndef _XML_HELPER_H#define _XML_HELPER_H#include <libxml/xmlmemory.h>#include <libxml/parser.h>#include <ext/rb_tree>#include <string>#include <iostream>#include <sstream>#include <stack>#include "Vector2.h"#include "Rect.h"#include "Color.h"#include "ScreenCoord.h"#include "PropertyList.h"#include "FileManager.h"#include "StringHelper.h"namespace Walaber {		class XML	{	public:		// --------========--------========--------========--------========--------========--------========		static inline bool attrExists( xmlNodePtr node, const char* attrName )		{			xmlChar* str = xmlGetProp(node, (const xmlChar*)attrName);			bool ret = (str != 0);			xmlFree(str);						return ret;		}				// --------========--------========--------========--------========--------========--------========		static inline int parseInt( xmlNodePtr node, const char* attrName )		{			int ret = 0;			xmlChar* prop = xmlGetProp(node, (const xmlChar*)attrName);			sscanf((const char*)prop, "%d", &ret);			xmlFree(prop);			return ret;		}				// --------========--------========--------========--------========--------========--------========		static inline float parseFloat( xmlNodePtr node, const char* attrName )		{			float ret = 0.0f;			xmlChar* prop = xmlGetProp(node, (const xmlChar*)attrName);			sscanf((const char*)prop, "%f", &ret);			xmlFree(prop);			return ret;		}				// --------========--------========--------========--------========--------========--------========		static inline bool parseBool( xmlNodePtr node, const char* attrName )		{			xmlChar* str = xmlGetProp(node, (const xmlChar*)attrName);			bool retVal = false;						if (strcmp((const char*)str, "true") == 0)				retVal =  true;			else if (strcmp((const char*)str, "True") == 0)				retVal =  true;			else if (strcmp((const char*)str, "TRUE") == 0)				retVal =  true;			else if (strcmp((const char*)str, "yes") == 0)				retVal =  true;			else if (strcmp((const char*)str, "Yes") == 0)				retVal =  true;			else if (strcmp((const char*)str, "YES") == 0)				retVal =  true;						xmlFree(str);						return retVal;		}				// --------========--------========--------========--------========--------========--------========		static inline ScreenCoord parseScreenCoord( xmlNodePtr node, const char* attrName)		{			float units[2];			int pixels[2];			xmlChar* prop = xmlGetProp(node, (const xmlChar*)attrName);			int numRead = sscanf((const char*)prop, "%f %f %d %d", &units[0], &units[1], &pixels[0], &pixels[1] );						if(numRead <= 2)			{				pixels[0] = 0;				pixels[1] = 0;			}						xmlFree(prop);			return ScreenCoord(units[0],units[1],pixels[0],pixels[1]);		}				// --------========--------========--------========--------========--------========--------========		static inline Vector2 parseVector2( xmlNodePtr node, const char* xAttr, const char* yAttr )		{			return Vector2( parseFloat(node, xAttr), parseFloat(node, yAttr) );		}				// --------========--------========--------========--------========--------========--------========		static inline Vector2 parseVector2( xmlNodePtr node, const char* attr )		{			Vector2 ret;			xmlChar* prop = xmlGetProp(node, (const xmlChar*)attr);			sscanf((const char*)prop, "%f %f", &ret.X, &ret.Y);			xmlFree(prop);			return ret;		}				// --------========--------========--------========--------========--------========--------========		static inline Color parseColor( xmlNodePtr node )		{			return Color( parseFloat(node, "colorR"), parseFloat(node, "colorG"), parseFloat(node, "colorB") );		}				// --------========--------========--------========--------========--------========--------========		static inline Color parseColor8bit( xmlNodePtr node, const char* attr )		{			Color ret;			xmlChar* prop = xmlGetProp(node, (const xmlChar*)attr);						ret = Color::parseColorFromString( (const char*)prop );						/*			int r, g, b;			sscanf((const char*)prop, "%d %d %d", &r, &g, &b);			xmlFree(prop);			ret = Color( r, g, b );			 */						xmlFree(prop);						return ret;		}				// --------========--------========--------========--------========--------========--------========		static inline Color parseColor8bitRGBA( xmlNodePtr node, const char* attr )		{			Color ret;			xmlChar* prop = xmlGetProp(node, (const xmlChar*)attr);						ret = Color::parseColorFromStringRGBA( (const char*)prop );						/*			 int r, g, b;			 sscanf((const char*)prop, "%d %d %d", &r, &g, &b);			 xmlFree(prop);			 ret = Color( r, g, b );			 */						xmlFree(prop);						return ret;		}				// --------========--------========--------========--------========--------========--------========		static inline Color parseColor( xmlNodePtr node, const char* rAttr, const char* gAttr, const char* bAttr )		{			return Color( parseFloat(node, rAttr), parseFloat(node, gAttr), parseFloat(node, bAttr) );		}				// --------========--------========--------========--------========--------========--------========		static inline Rect parseRect( xmlNodePtr node, const char* posAttr, const char* sizeAttr )		{			Vector2 pos = parseVector2(node, posAttr);			Vector2 size = parseVector2(node, sizeAttr);			return Rect( pos, size );		}				// --------========--------========--------========--------========--------========--------========		static inline Rect parseRect( xmlNodePtr node, const char* attr )		{			Rect ret;			xmlChar* prop = xmlGetProp(node, (const xmlChar*)attr);			sscanf((const char*)prop, "%f %f %f %f", &ret.upper_left.X, &ret.upper_left.Y, &ret.size.X, &ret.size.Y);			xmlFree(prop);			return ret;		}				// --------========--------========--------========--------========--------========--------========		static inline std::string parseString( xmlNodePtr node, const char* attr )		{			xmlChar* prop = xmlGetProp(node, (const xmlChar*)attr);			std::string ret( (const char*)prop );			xmlFree(prop);			return ret;		}						// --------========--------========--------========--------========--------========--------========		static inline void parsePropertyList( xmlNodePtr plistRoot, PropertyList& plist )		{			for (xmlNodePtr prop = plistRoot->children; prop; prop = prop->next)			{				if (xmlStrcmp(prop->name, (const xmlChar*)"Property") == 0)					plist.setValueForKey( parseString(prop, "name"), Property( parseString(prop, "value") ) );			}		}				// --------========--------========--------========--------========--------========--------========		static inline float parseAspectRatio( xmlNodePtr node, const char* attr )		{			float aspect = 1.0f;						std::string aspectStr = XML::parseString(node, attr);			if (StringHelper::stringContains(aspectStr, ":"))			{				int n = 1;				int d = 1;								sscanf(aspectStr.c_str(), "%d:%d", &n, &d);				aspect = (float)n / (float)d;			}			else			{				aspect = XML::parseFloat(node, attr);			}													 			return aspect;		}				// --------========--------========--------========--------========--------========--------========		static inline void newColor( xmlNodePtr node, const char* attr, const Color& col )		{			char buffer[30];			snprintf(buffer, 30, "%c %c %c", col.R, col.G, col.B);			xmlNewProp(node, (const xmlChar*)attr, (const xmlChar*)buffer);		}				// --------========--------========--------========--------========--------========--------========		static inline void newVector2( xmlNodePtr node, const char* attr, const Vector2& vec )		{			char buffer[30];			snprintf(buffer, 30, "%f %f", vec.X, vec.Y);			xmlNewProp(node, (const xmlChar*)attr, (const xmlChar*)buffer);		}				// --------========--------========--------========--------========--------========--------========		static inline void newFloat( xmlNodePtr node, const char* attr, float val )		{			char buffer[30];			snprintf(buffer, 30, "%f", val);			xmlNewProp(node, (const xmlChar*)attr, (const xmlChar*)buffer);		}				// --------========--------========--------========--------========--------========--------========		static inline void newInt( xmlNodePtr node, const char* attr, int val )		{			char buffer[30];			snprintf(buffer, 30, "%d", val);			xmlNewProp(node, (const xmlChar*)attr, (const xmlChar*)buffer);		}		        // --------========--------========--------========--------========--------========--------========		static inline void newString( xmlNodePtr node, const char* attr, const std::string& val )		{			xmlNewProp(node, (const xmlChar*)attr, (const xmlChar*)val.c_str());		}                // --------========--------========--------========--------========--------========--------========		static inline void newBool( xmlNodePtr node, const char* attr, const bool val )		{            char buffer[6];            if(val)            {                snprintf(buffer, 6, "%s", "true");            }            else            {                snprintf(buffer, 6, "%s", "false");            }			xmlNewProp(node, (const xmlChar*)attr, (const xmlChar*)buffer);		}        		// --------========--------========--------========--------========--------========--------========		static inline void newPropertyList( xmlNodePtr parent_node, const PropertyList& plist, std::string name = "Properties" )		{			xmlNodePtr propListNode = xmlNewChild( parent_node, NULL, (const xmlChar*)name.c_str(), NULL);						for (PropertyList::PropertyMap::const_iterator p = plist.begin(); p != plist.end(); ++p)			{				xmlNodePtr propNode = xmlNewChild( propListNode, NULL, (const xmlChar*)"Property", NULL);				xmlNewProp( propNode, (const xmlChar*)"name", (const xmlChar*)p->first.c_str() );				xmlNewProp( propNode, (const xmlChar*)"value", (const xmlChar*)p->second.asString().c_str() );			}		}    		// --------========--------========--------========--------========--------========--------========		static inline xmlNodePtr addNewChild( xmlNodePtr parent_node, const char* elemName, const char* value )		{			return xmlNewChild(parent_node, 0, (const xmlChar*)elemName, (const xmlChar*)value);		}        		// --------========--------========--------========--------========--------========--------========		static inline xmlNodePtr loadDoc( std::string filename, std::string rootElementName, xmlDocPtr& outDocPtr )		{			xmlNodePtr root_elem = NULL;			#ifdef _DEBUG			printf("XMLHelper::loadDoc(%s)\n", filename.c_str());#endif			outDocPtr = xmlReadFile( filename.c_str(), NULL, 0);									root_elem = xmlDocGetRootElement(outDocPtr);						if (!root_elem)			{				printf("ERROR! no root element in XML file:%s\n", filename.c_str());				xmlFreeDoc(outDocPtr);				xmlCleanupMemory();				return NULL;			}						if (xmlStrcmp(root_elem->name, (const xmlChar*)rootElementName.c_str()))			{				printf("ERROR! Xml file root(%s) does not match '%s' in file:%s\n", (const char*)root_elem->name, rootElementName.c_str(), filename.c_str());				xmlFreeDoc(outDocPtr);				xmlCleanupMemory();				return NULL;			}						return root_elem;		}                // --------========--------========--------========--------========--------========--------========		static inline xmlNodePtr loadDoc( std::string filename, xmlDocPtr& outDocPtr )		{			xmlNodePtr root_elem = NULL;			#ifdef _DEBUG			printf("XMLHelper::loadDoc(%s)\n", filename.c_str());#endif			outDocPtr = xmlReadFile( filename.c_str(), NULL, 0);            			root_elem = xmlDocGetRootElement(outDocPtr);						if (!root_elem)			{				printf("ERROR! no root element in XML file:%s\n", filename.c_str());				xmlFreeDoc(outDocPtr);				xmlCleanupMemory();				return NULL;			}            			return root_elem;		}				// --------========--------========--------========--------========--------========--------========		static inline xmlNodePtr loadDocMemory( char* fileBuffer, size_t length, std::string rootElementName, xmlDocPtr& outDocPtr )		{			xmlNodePtr root_elem = NULL;			#ifdef _DEBUG			printf("XMLHelper::loadDocMemory\n");#endif						outDocPtr = xmlReadMemory( fileBuffer, length, NULL, NULL, 0);						root_elem = xmlDocGetRootElement(outDocPtr);						if (!root_elem)			{				printf("ERROR! no root element in XML\n");				xmlFreeDoc(outDocPtr);				xmlCleanupMemory();				return NULL;			}						if (xmlStrcmp(root_elem->name, (const xmlChar*)rootElementName.c_str()))			{				printf("ERROR! Xml file root(%s) does not match '%s' in XML\n", (const char*)root_elem->name, rootElementName.c_str());				xmlFreeDoc(outDocPtr);				xmlCleanupMemory();				return NULL;			}						return root_elem;		}                // --------========--------========--------========--------========--------========--------========		static inline xmlNodePtr loadDocMemory( char* fileBuffer, size_t length, xmlDocPtr& outDocPtr )		{			xmlNodePtr root_elem = NULL;			#ifdef _DEBUG			printf("XMLHelper::loadDocMemory\n");#endif						outDocPtr = xmlReadMemory( fileBuffer, length, NULL, NULL, 0);						root_elem = xmlDocGetRootElement(outDocPtr);						if (!root_elem)			{				printf("ERROR! no root element in XML\n");				xmlFreeDoc(outDocPtr);				xmlCleanupMemory();				return NULL;			}						return root_elem;		}				// --------========--------========--------========--------========--------========--------========		static inline void cleanupDoc( xmlDocPtr doc )		{			xmlFreeDoc(doc);			xmlCleanupMemory();		}						// --------========--------========--------========--------========--------========--------========		static inline xmlNodePtr newDoc( std::string rootNodeName, xmlDocPtr& outDocPtr )		{			outDocPtr = NULL;			xmlNodePtr root_node = NULL;/* node pointers */			outDocPtr = xmlNewDoc((const xmlChar*)"1.0");						//set root			root_node = xmlNewNode(NULL, (const xmlChar*)rootNodeName.c_str());						xmlDocSetRootElement(outDocPtr, root_node);			return root_node;		}				// --------========--------========--------========--------========--------========--------========		static inline void saveDoc( std::string path, xmlDocPtr doc )		{			xmlSaveFormatFile(path.c_str(), doc, 1);		}		        // returns first node of element "nodeName" in depth first search		// --------========--------========--------========--------========--------========--------========		static inline xmlNodePtr getNode(xmlNodePtr root, const std::string& nodeName)        {            std::stack<xmlNodePtr> nodeStack;                        if(root->children)            {                nodeStack.push(root->children);            }                        while(!nodeStack.empty())            {                xmlNodePtr node = nodeStack.top();                nodeStack.pop();                                if(!xmlStrcmp(node->name, (const xmlChar*)nodeName.c_str()))                {                    return node;                }                                if(node->next)                {                    nodeStack.push(node->next);                }                                if(node->children)                {                    nodeStack.push(node->children);                }            }                        return 0;        }	};	}#endif	// _XML_HELPER_H
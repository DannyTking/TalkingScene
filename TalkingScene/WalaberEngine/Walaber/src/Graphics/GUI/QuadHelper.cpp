#include "QuadHelper.h"#include "VectorTools.h"#include <Vector2.h>#include <Rect.h>#include <Color.h>#include <GraphicsGL.h>namespace Walaber{	GLfloat QuadHelper::mVerts[8] = 	{ -0.5f, -0.5f,	  0.5f, -0.5f,	  -0.5f, 0.5f,	  0.5f, 0.5f };		GLfloat QuadHelper::mTexCoords[8] =	{ 0.0f, 1.0f,	  1.0f, 1.0f,	  0.0f, 0.0f,	  1.0f, 0.0f };		GLfloat QuadHelper::mCustomTexCoords[8] =	{ 0.0f, 1.0f,		1.0f, 1.0f,		0.0f, 0.0f,		1.0f, 0.0f };		GLuint QuadHelper::mColors[4] = 	{		packColor( 255, 255, 255, 255 ),		packColor( 255, 255, 255, 255 ),		packColor( 255, 255, 255, 255 ),		packColor( 255, 255, 255, 255 )	};		void QuadHelper::drawQuad( GLuint textureName, const Vector2& pos, float angle, const Vector2& size, const Color& c )	{				GLuint packedC = packColor(c.R, c.G, c.B, c.A);		for (unsigned int i = 0; i < 4; i++)			mColors[i] = packedC;				GraphicsGL::setBlending(true);		GraphicsGL::setTextureEnabled(true);				GraphicsGL::bindTexture(textureName);				glTexCoordPointer(2, GL_FLOAT, 8, mTexCoords);        GraphicsGL::enableTextureClientState();				glVertexPointer(2, GL_FLOAT, 8, mVerts);        GraphicsGL::enableVertexClientState();				glColorPointer(4, GL_UNSIGNED_BYTE, 4, mColors);        GraphicsGL::enableColorClientState();						glMatrixMode(GL_MODELVIEW);		glPushMatrix();		glTranslatef( pos.X, pos.Y, 0.0f );		glRotatef(angle, 0.0f, 0.0f, 1.0f);		 		glScalef(size.X, size.Y, 1.0f);		glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);				glPopMatrix();	}			void QuadHelper::drawQuad( GLuint textureName, const Vector2& pos, float angle, const Vector2& size, const Rect& uvs, unsigned int wrapS, unsigned int wrapT, const Color& c, bool forceWrap)	{		mCustomTexCoords[0] = uvs.upper_left.X;		mCustomTexCoords[1] = uvs.getBottomRight().Y;				mCustomTexCoords[2] = uvs.getBottomRight().X;		mCustomTexCoords[3] = uvs.getBottomRight().Y;				mCustomTexCoords[4] = uvs.upper_left.X;		mCustomTexCoords[5] = uvs.upper_left.Y;				mCustomTexCoords[6] = uvs.getBottomRight().X;		mCustomTexCoords[7] = uvs.upper_left.Y;				GLuint packedC = packColor(c.R, c.G , c.B , c.A );		for (unsigned int i = 0; i < 4; i++)			mColors[i] = packedC;						GraphicsGL::setBlending(true);		GraphicsGL::setTextureEnabled(true);				GraphicsGL::bindTexture(textureName);                //if (forceWrap)        //    GraphicsGL::setTextureWrap(wrapS,wrapT, true);        				glTexCoordPointer(2, GL_FLOAT, 8, mCustomTexCoords);		GraphicsGL::enableTextureClientState();				glVertexPointer(2, GL_FLOAT, 8, mVerts);		GraphicsGL::enableVertexClientState();				glColorPointer(4, GL_UNSIGNED_BYTE, 4, mColors);		GraphicsGL::enableColorClientState();				glMatrixMode(GL_MODELVIEW);		glPushMatrix();				glTranslatef( pos.X, pos.Y, 0.0f );		glRotatef(angle, 0.0f, 0.0f, 1.0f);				glScalef(size.X, size.Y, 1.0f);		glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);				glPopMatrix();	}		void QuadHelper::drawQuad( GLuint textureName, const Vector2& pos, float angle, const Vector2& size, const Rect& uvs, const Color& c)	{		QuadHelper:: drawQuad(textureName, pos, angle, size, uvs, GL_CLAMP_TO_EDGE, GL_CLAMP_TO_EDGE, c, false );	}		void QuadHelper::drawQuad( const Vector2& pos, float angle, const Vector2& size, const Color& c )	{		GLuint packedC = packColor(c.R , c.G , c.B , c.A );		for (unsigned int i = 0; i < 4; i++)			mColors[i] = packedC;						GraphicsGL::setBlending(true);		GraphicsGL::setTextureEnabled(true);				glTexCoordPointer(2, GL_FLOAT, 8, mTexCoords);		GraphicsGL::enableTextureClientState();				glVertexPointer(2, GL_FLOAT, 8, mVerts);		GraphicsGL::enableVertexClientState();				glColorPointer(4, GL_UNSIGNED_BYTE, 4, mColors);		GraphicsGL::enableColorClientState();				glMatrixMode(GL_MODELVIEW);		glPushMatrix();				glTranslatef( pos.X, pos.Y, 0.0f );		glRotatef(angle, 0.0f, 0.0f, 1.0f);				glScalef(size.X, size.Y, 1.0f);		glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);				glPopMatrix();	}			void QuadHelper::drawQuadColored( const Vector2& pos, float angle, const Vector2& size, const Color& col )	{		GLuint packedC = packColor(col.R , col.G , col.B , col.A );		for (unsigned int i = 0; i < 4; i++)			mColors[i] = packedC;						GraphicsGL::setBlending(true);		GraphicsGL::setTextureEnabled(false);		        GraphicsGL::disableTextureClientState();		//glDisableClientState(GL_TEXTURE_COORD_ARRAY);				glVertexPointer(2, GL_FLOAT, 8, mVerts);		GraphicsGL::enableVertexClientState();				glColorPointer(4, GL_UNSIGNED_BYTE, 4, mColors);		GraphicsGL::enableColorClientState();						glMatrixMode(GL_MODELVIEW);		glPushMatrix();				glTranslatef( pos.X, pos.Y, 0.0f );		glRotatef(angle, 0.0f, 0.0f, 1.0f);				glScalef(size.X, size.Y, 1.0f);		glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);				glPopMatrix();	}		void QuadHelper::drawQuadOutline( const Vector2& pos, float angle, const Vector2& size, float thickness, const Color& col )	{		// draw 4 quads to make an outlined rectangle.		Vector2 tbSize( size.X - thickness, thickness );		Vector2 lrSize( thickness, size.Y + thickness );				// top		QuadHelper::drawQuadColored( pos + VectorTools::rotateVector( Vector2(0.0f, size.Y * 0.5f), degToRad(angle)),									angle,									tbSize,									col);				// bottom		QuadHelper::drawQuadColored( pos + VectorTools::rotateVector( Vector2(0.0f, -size.Y * 0.5f), degToRad(angle)),									angle,									tbSize,									col);				// left		QuadHelper::drawQuadColored( pos + VectorTools::rotateVector( Vector2(-size.X * 0.5f, 0.0f), degToRad(angle)),									angle,									lrSize,									col);				// right		QuadHelper::drawQuadColored( pos + VectorTools::rotateVector( Vector2(size.X * 0.5f, 0.0f), degToRad(angle)),									angle,									lrSize,									col);	}	}